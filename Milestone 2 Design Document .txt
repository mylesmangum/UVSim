Milestone 2 Design Document 
CS-2450
Group D
5/27/25
Project Overview
UVSim is a command‑line Java program that behaves like a 100‑word, accumulator‑based machine. It loads a text file containing four digit BasicML instructions into main memory, then fetches, decodes, and executes each instruction.
Every subsystem (memory, CPU loop, loader, console) lives in its own class, and all numeric limits are checked with appropriate error messages.


Memory Class
A thin wrapper around a fixed integer array of 100 words.
Holds int[] cells = new int[100].
Provides read(int addr) and write(int addr, int word) that first verify 0 ≤ addr ≤ 99. Otherwise throw an exception.


UVCpu Class
Holds the processor state and the fetch, decode, execute loop.
Fields: int pc (program counter), int acc (accumulator), boolean halted, and a reference to both  a Memory and a Console instance.
void run() keeps looping until halted is true, calling fetch() and decode().



UVConsole Class
An I/O interface that captures input and output to the console.
String readLine() and void println(String s) provide this functionality.
________________




User Stories
As a CS student, I want to run my BasicML program inside UVSim so that I can debug my homework quickly by watching how each instruction affects the accumulator and memory.


As teacher, I want to get a clear descriptive error message when a student’s program crashes so that I can give equally clear and descriptive feedback on their assignments.






________________








Use Cases
1.  Load Program File
* Actor: Student at the keyboard
* System: ProgramLoader + Memory
* Goal: Populate memory locations 00‑NN with the words from the selected text file.
1. Prompt user for filename.
2. Open file and read each line.
3. Convert each line to an int word; ignore blank lines and comments.
4. Write the word into the next memory cell.
5. Close the file; return success or error (file not found etc.).
2.  Validate Memory Address
* Actor: Memory class internals
* System: Memory bounds checker
* Goal: Prevent illegal access outside 0‑99.
1. Receive a read(addr) or write(addr,val) request.
2. If addr < 0 or > 99, throw exception.
3. Otherwise continue with the read or write.
3.  Fetch Instruction
* Actor: CPU fetch‑decode‑execute loop
* System: UVCpu
* Goal: Retrieve the next instruction word for decoding.
1. Read memory at programCounter.
2. Split the four digit word into opcode (first 2) and operand (last 2).
3. Increment programCounter to point to the subsequent cell.
4.  READ (10)
* Actor: Student user
* System: Console handler
* Goal: Store a keyboard value into memory.
1. CPU decodes opcode 10.
2. Prompt: "Enter a signed four digit word:" 
3. Parse input, validate it fits +/-9999.
4. Write the value to operand memory address.
5.  WRITE (11)
* Actor: CPU
* System: Console handler
* Goal: Display a word from memory.
1. Fetch value from operand address.
2. Print value with sign and leading zeros.
6.  LOAD (20)
* Actor: CPU
* System: Register logic
* Goal: Move a word from memory into the accumulator.
1. Fetch value at operand address.
2. Copy value into accumulator register.
7.  STORE (21)
* Actor: CPU
* System: Register logic
* Goal: Save the accumulator back to memory.
1. Read current accumulator.
2. Write it to operand address in memory.
8.  ADD (30) & SUBTRACT (31)
* Actor: CPU arithmetic unit
* System: ALU emulation
* Goal: Update accumulator with addition or subtraction.
1. Fetch operand value.
2. Compute acc = acc +/- operand.
3. If |acc| > 9999, flag overflow, print error, HALT.
4. Otherwise storethe result in accumulator.
9.  DIVIDE (32)
* Actor: CPU arithmetic unit
* System: ALU emulation
* Goal: Divide accumulator by operand.
1. Fetch operand value.
2. If operand == 0, print divide by zero error, HALT.
3. Else compute integer division, store in accumulator.
4. 9.  MULTIPLY (33)
* Actor: CPU arithmetic unit
* System: ALU emulation
* Goal: Multiply accumulator by a word from memory.
* Fetch operand value from memory.
* Compute acc = acc * operand.
* If |acc| > 9999, flag overflow, print an error, and HALT.
* Otherwise, store the result in the accumulator.


10.  BRANCH (40) / BRANCHNEG (41) / BRANCHZERO (42)
* Actor: CPU control unit
* System: Program counter manager
* Goal: Alter sequential flow when conditions are met.
1. Evaluate condition (always true, acc < 0, or acc == 0).
2. If true, set programCounter = operand; else continue sequentially.
11.  HALT (43)
* Actor: CPU loop
* System: UVCpu
* Goal: End program execution cleanly.
1. Detect opcode 43.
2. Print "Program halted normally."
3. Break out of main loop and exit to OS.
12.  Runtime Exception Handling
* Actor: Error‑monitor sub‑routine
* System: UVCpu
* Goal: Stop execution and dump context when a fatal error occurs.
1. Receive error signal (overflow, divide‑by‑zero, bad opcode).
2. Print descriptive message including PC and accumulator value.
3. Dump memory snapshot (optional).
4. Set CPU state to halted.